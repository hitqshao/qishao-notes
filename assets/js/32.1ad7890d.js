(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{484:function(e,s,t){"use strict";t.r(s);var n=t(8),a=Object(n.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h3",{attrs:{id:"chapter-1-toy-language-and-ast"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#chapter-1-toy-language-and-ast"}},[e._v("#")]),e._v(" Chapter 1. Toy Language and AST")]),e._v(" "),s("p",[e._v("Lexer and recursive descent parser construt AST")]),e._v(" "),s("h3",{attrs:{id:"chapter-2-emit-basic-mlir"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#chapter-2-emit-basic-mlir"}},[e._v("#")]),e._v(" Chapter 2. Emit Basic MLIR")]),e._v(" "),s("p",[e._v("Operations: instructions, globals(functions), modules, in LLVM")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://github.com/user-attachments/assets/1547200e-1e13-4075-b202-77be37cf0b74",alt:"image"}}),e._v("\nFrom "),s("a",{attrs:{href:"https://medium.com/sniper-ai/mlir-tutorial-create-your-custom-dialect-lowering-to-llvm-ir-dialect-system-1-1f125a6a3008",target:"_blank",rel:"noopener noreferrer"}},[e._v("link"),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("Transpose Operation")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('%t_tensor = "toy.transpose"(%tensor) {inplace = true} : (tensor<2x3xf64>) ->\ntensor<3x2xf64> loc("example/file/path":12:1)\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("meaning of each part")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("result  = name of operation (input operands) dictionary of traits :\ntype of operations (input and output), location\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("ul",[s("li",[e._v("A name for the operation.")]),e._v(" "),s("li",[e._v("A list of SSA operand values.")]),e._v(" "),s("li",[e._v("A list of attributes.")]),e._v(" "),s("li",[e._v("A list of types for result values.")]),e._v(" "),s("li",[e._v("A source location for debugging purposes.")]),e._v(" "),s("li",[e._v("A list of successors blocks (for branches, mostly).")]),e._v(" "),s("li",[e._v("A list of regions (for structural operations like functions).")])]),e._v(" "),s("p",[s("strong",[e._v("Opaque API")])]),e._v(" "),s("p",[s("strong",[e._v("Define a Toy Dialect")])]),e._v(" "),s("p",[e._v("dialect could be defined by c++ or tablegen(declarative specification).")]),e._v(" "),s("p",[e._v("after the definiation, it could be loaded to MLIR Context.\ncontext.loadDialect"),s("ToyDialect",[e._v("();")])],1),e._v(" "),s("p",[s("strong",[e._v("Defining Toy Operations")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class ConstantOp : public mlir::Op<\n                     /// `mlir::Op` is a CRTP class, meaning that we provide the\n                     /// derived class as a template parameter.\n                     ConstantOp,\n                     /// The ConstantOp takes zero input operands.\n                     mlir::OpTrait::ZeroOperands,\n                     /// The ConstantOp returns a single result.\n                     mlir::OpTrait::OneResult,\n                     /// We also provide a utility `getType` accessor that\n                     /// returns the TensorType of the single result.\n                     mlir::OpTraits::OneTypedResult<TensorType>::Impl> {\n\n public:\n  /// Inherit the constructors from the base Op class.\n  using Op::Op;\n  ...\n  static void build(mlir::OpBuilder &builder, mlir::OperationState &state,\n                    mlir::Type result, mlir::DenseElementsAttr value);\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br")])]),s("p",[e._v("register operation:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("void ToyDialect::initialize() {\n  addOperations<ConstantOp>();\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[s("strong",[e._v("Op vs Operation: Using MLIR Operations")])]),e._v(" "),s("p",[s("strong",[e._v("Using Operation Definition Specification Framwork")])]),e._v(" "),s("p",[e._v("base Toy_Op")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Toy_Op<string mnemonic, list<Trait> traits = []> :\n    Op<Toy_Dialect, mnemonic, traits>;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("ConstantOp")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('def ConstantOp : Toy_Op<"constant"> {\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[s("strong",[e._v("Attaching build Methods")])]),e._v(" "),s("p",[e._v("In ConstantOp, it declared a list of build. ODS will generate the first build."),s("br"),e._v("\nAs to other builds, we have to atttach.")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('def ConstantOp : Toy_Op<"constant"> {\n  ...\n\n  // Add custom build methods for the constant operation. These methods populate\n  // the `state` that MLIR uses to create operations, i.e. these are used when\n  // using `builder.create<ConstantOp>(...)`.\n  let builders = [\n    // Build a constant with a given constant tensor value.\n    OpBuilder<(ins "DenseElementsAttr":$value), [{\n      // Call into an autogenerated `build` method.\n      build(builder, result, value.getType(), value);\n    }]>,\n\n    // Build a constant with a given constant floating-point value. This builder\n    // creates a declaration for `ConstantOp::build` with the given parameters.\n    OpBuilder<(ins "double":$value)>\n  ];\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br")])]),s("p",[s("strong",[e._v("Specifying a Custom Assembly Format")])]),e._v(" "),s("p",[e._v("The printout version of IR has too much information.")]),e._v(" "),s("p",[e._v("We can strip out by implementing our owne oversion of print and parse function.")]),e._v(" "),s("p",[e._v("Take PrintOp as example.")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('void PrintOp::print(mlir::OpAsmPrinter &printer) {\n  printer << "toy.print " << op.input();\n  printer.printOptionalAttrDict(op.getAttrs());\n  printer << " : " << op.input().getType();\n}\n\nmlir::ParseResult PrintOp::parse(mlir::OpAsmParser &parser,\n                                 mlir::OperationState &result) {\n...\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("h3",{attrs:{id:"chapter-3-high-level-language-specific-analysis-and-transformation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#chapter-3-high-level-language-specific-analysis-and-transformation"}},[e._v("#")]),e._v(" Chapter 3. High-level Language-Specific Analysis and Transformation")]),e._v(" "),s("ul",[s("li",[e._v("Imperative, C++ Pattern match and Rewrite")]),e._v(" "),s("li",[e._v("Decalrative, rule-based pattern-match and rewrite using table-driven")])]),e._v(" "),s("p",[s("strong",[e._v("C++")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('/// Fold transpose(transpose(x)) -> x\nstruct SimplifyRedundantTranspose : public mlir::OpRewritePattern<TransposeOp> {\n  /// We register this pattern to match every toy.transpose in the IR.\n  /// The "benefit" is used by the framework to order the patterns and process\n  /// them in order of profitability.\n  SimplifyRedundantTranspose(mlir::MLIRContext *context)\n      : OpRewritePattern<TransposeOp>(context, /*benefit=*/1) {}\n\n  /// This method is attempting to match a pattern and rewrite it. The rewriter\n  /// argument is the orchestrator of the sequence of rewrites. It is expected\n  /// to interact with it to perform any changes to the IR from here.\n  llvm::LogicalResult\n  matchAndRewrite(TransposeOp op,\n                  mlir::PatternRewriter &rewriter) const override {\n    // Look through the input of the current transpose.\n  ....\n  }\n};\n\n// Register our patterns for rewrite by the Canonicalization framework.\nvoid TransposeOp::getCanonicalizationPatterns(\n    RewritePatternSet &results, MLIRContext *context) {\n  results.add<SimplifyRedundantTranspose>(context);\n}\n\n// Add into Pass Manager\nmlir::PassManager pm(module->getName());\npm.addNestedPass<mlir::toy::FuncOp>(mlir::createCanonicalizerPass());\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br")])]),s("p",[s("strong",[e._v("rule-based pattern-match and rewrite (DRR)")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('def TypesAreIdentical : Constraint<CPred<"$0.getType() == $1.getType()">>;\ndef RedundantReshapeOptPattern : Pat<\n  (ReshapeOp:$res $arg), (replaceWithValue $arg),\n  [(TypesAreIdentical $res, $arg)]>;\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])])])}),[],!1,null,null,null);s.default=a.exports}}]);