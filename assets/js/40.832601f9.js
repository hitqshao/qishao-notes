(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{451:function(s,n,t){"use strict";t.r(n);var i=t(5),a=Object(i.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("ul",[n("li",[s._v("libcuda\n"),n("ul",[n("li",[s._v("cuda_runtime_api.cc")])])]),s._v(" "),n("li",[s._v("src\n"),n("ul",[n("li",[s._v("abstract_hardware_model.h/cpp")]),s._v(" "),n("li",[s._v("gpgpusim_entrypoint.h/cpp")]),s._v(" "),n("li",[s._v("stream_manager.h/cpp")]),s._v(" "),n("li",[s._v("cuda-sim\n"),n("ul",[n("li",[n("p",[s._v("cuda-sim.h/cc\n🐝")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void function_info::ptx_assemble() {\n for ( i=m_instructions.begin(); i != m_instructions.end(); i++ ) {\n  // map pc to instruction\n  g_pc_to_finfo[PC] = this;\n  // This is a uniform array, each entry is one instruction\n  m_instr_mem[n] = pI; \n  s_g_pc_to_insn.push_back(pI);\n  ssert(pI == s_g_pc_to_insn[PC]);\n  pI->set_m_instr_mem_index(n);\n  pI->set_PC(PC);\n }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])])]),s._v(" "),n("li",[n("p",[s._v("memory.h/cc")])]),s._v(" "),n("li",[n("p",[s._v("opcode.h/def")])]),s._v(" "),n("li",[n("p",[s._v("ptx_loader.h/cc")])]),s._v(" "),n("li",[n("p",[s._v("ptx.y"),n("br"),s._v("\nIt is a Yacc/Bison grammar file used to parse PTX (Parallel Thread Execution) assembly code, which is a low-level intermediate representation used by NVIDIA GPUs."),n("br"),s._v("\nIt defines the grammar rules for PTX assembly code and specifies how different components of PTX code should be interpreted and processed."),n("br"),s._v("\nThis includes recognizing various PTX instructions, operands, directives, and control structures, and translating them into an internal representation that the simulator can work with.")]),s._v(" "),n("p",[s._v("When it meets instruction statement it will call add_instruction.")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("statement_list: directive_statement { add_directive(); }\n| instruction_statement { add_instruction();}\n...\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])])]),s._v(" "),n("li",[n("p",[s._v("ptx_parser.h/cc\nthe add_instruction used in ptx.y will call the following instruction.")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void add_instruction() \n{\nptx_instruction *i = new ptx_instruction(**);\ng_instructions.push_back(i);\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("in the end of function it will add all the instructins into function infomation")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void end_function()\n{\n...\ng_func_info->add_inst( g_instructions );\n...\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])])]),s._v(" "),n("li",[n("p",[s._v("ptx_ir.h/cc")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//@@@@@@ ptx_ir.h\n...\nstd::vector<const symbol*> m_args;\n// end_function will put function into this list\nstd::list<ptx_instruction*> m_instructions;\nstd::vector<basic_block_t*> m_basic_blocks;\n\n//@@@@@@ ptx_ir.cc\nvoid gpgpu_ptx_assemble( std::string kname, void *kinfo ) {\n function_info *func_info = (function_info *)kinfo;\n // This will call cuda_sim ptx_assemble function\n func_info->ptx_assemble();\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])])]),s._v(" "),n("li",[n("p",[s._v("ptx_sim.h/cc")])])])]),s._v(" "),n("li",[s._v("gpgpu-sim\n"),n("ul",[n("li",[s._v("gpgpu-sim.h/cc")]),s._v(" "),n("li",[s._v("shader.h/shader.cc")]),s._v(" "),n("li",[s._v("mem_fetch.h/cc")]),s._v(" "),n("li",[s._v("stack.h/cc")]),s._v(" "),n("li",[s._v("addrdec.h/cc")]),s._v(" "),n("li",[s._v("dram.h/cc")]),s._v(" "),n("li",[s._v("traffic_breakdown.h/cc")])])])])])]),s._v(" "),n("h3",{attrs:{id:"how-did-gpgpu-sim-get-instruction-from-cuda"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#how-did-gpgpu-sim-get-instruction-from-cuda"}},[s._v("#")]),s._v(" How did GPGPU-sim get instruction from CUDA?")]),s._v(" "),n("p",[s._v("🐝 show how Yacc/Bison grammar file is used to add instruction in function_info.\nNow we will describe how GPGPU-sim execute each instructin.")]),s._v(" "),n("h4",{attrs:{id:""}},[n("a",{staticClass:"header-anchor",attrs:{href:"#"}},[s._v("#")])]),s._v(" "),n("p",[s._v("abstract_hardware_model.cc implement this function, if you provde a warpId, it can return warp_instruction."),n("br"),s._v("\nThus, if we know next pc, we can use ptx_fetch_inst to get instruction.")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// @@@@@@ abstract_hardware_model.cc\n//! Get the warp to be executed using the data taken form the SIMT stack\nwarp_inst_t core_t::getExecuteWarp(unsigned warpId)\n{\n    unsigned pc,rpc;\n    m_simt_stack[warpId]->get_pdom_stack_top_info(&pc,&rpc);\n    warp_inst_t wi= *ptx_fetch_inst(pc);\n    wi.set_active(m_simt_stack[warpId]->get_active_mask());\n    return wi;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// @@@@@@ cuda-sim.cc\nconst warp_inst_t *ptx_fetch_inst( address_type pc )\n{\n    return function_info::pc_to_instruction(pc);\n}\n\n// @@@@@@ ptx_ir.h\nstatic const ptx_instruction* pc_to_instruction(unsigned pc) \n{\n  if( pc < s_g_pc_to_insn.size() )\n      return s_g_pc_to_insn[pc];\n  else\n      return NULL;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])])])}),[],!1,null,null,null);n.default=a.exports}}]);