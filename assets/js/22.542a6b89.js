(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{439:function(t,e,s){"use strict";s.r(e);var a=s(5),i=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("llvm front end demo\nNotes from "),e("strong",[t._v("Life of an instruction in LLVM")]),t._v("\nhttps://blog.llvm.org/2012/11/life-of-instruction-in-llvm.html")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"programing-language-dependent"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#programing-language-dependent"}},[t._v("#")]),t._v(" Programing Language Dependent")]),t._v(" "),e("h3",{attrs:{id:"_1-clang-parser-will-build-an-abstract-syntax-tree-ast"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-clang-parser-will-build-an-abstract-syntax-tree-ast"}},[t._v("#")]),t._v(" 1. Clang parser will build an Abstract Syntax Tree(AST)")]),t._v(" "),e("h4",{attrs:{id:"input"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#input"}},[t._v("#")]),t._v(" Input")]),t._v(" "),e("p",[t._v("High-level source code (e.g., C, C++).")]),t._v(" "),e("h4",{attrs:{id:"output"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#output"}},[t._v("#")]),t._v(" Output")]),t._v(" "),e("p",[t._v("An AST, which is a tree structure representing the syntactic structure of the source code")]),t._v(" "),e("h4",{attrs:{id:"tool"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tool"}},[t._v("#")]),t._v(" Tool")]),t._v(" "),e("p",[t._v("Clang Frontend")]),t._v(" "),e("h4",{attrs:{id:"transformation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#transformation"}},[t._v("#")]),t._v(" Transformation")]),t._v(" "),e("p",[t._v("The compiler’s frontend (Clang in LLVM) parses the source code and constructs an AST."),e("br"),t._v("\nThe AST captures the hierarchical structure of the program based on grammar rules (e.g., function definitions, statements, expressions).")]),t._v(" "),e("h4",{attrs:{id:"reason"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reason"}},[t._v("#")]),t._v(" Reason")]),t._v(" "),e("p",[t._v("The AST is closely tied to the original source code and allows easy analysis and checking of syntactic correctness."),e("br"),t._v("\nIt serves as a starting point for semantic analysis (e.g., type checking, variable scoping) before code generation.")]),t._v(" "),e("h4",{attrs:{id:"key-source-file"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-source-file"}},[t._v("#")]),t._v(" Key Source File")]),t._v(" "),e("p",[t._v("clang/lib/AST/")]),t._v(" "),e("h4",{attrs:{id:"key-functions-classes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-functions-classes"}},[t._v("#")]),t._v(" Key Functions/Classes")]),t._v(" "),e("h5",{attrs:{id:"parseast"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parseast"}},[t._v("#")]),t._v(" ParseAST")]),t._v(" "),e("p",[t._v("The function responsible for initiating the parsing of source code to generate an Abstract Syntax Tree (AST)."),e("br"),t._v(" "),e("strong",[t._v("Function")]),t._v(": This function takes the parsed tokens from the lexer and generates the AST by applying grammar rules."),e("br"),t._v("\nIt processes the input source code and organizes it into hierarchical structures like functions, expressions, and statements.")]),t._v(" "),e("h4",{attrs:{id:"sema"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sema"}},[t._v("#")]),t._v(" Sema")]),t._v(" "),e("p",[t._v("The Sema class in Clang performs semantic analysis on the AST."),e("br"),t._v(" "),e("strong",[t._v("Function")]),t._v(": After parsing the AST, Sema checks the semantic validity of the code, ensuring things like proper type usage, function declarations, and scope resolution.")]),t._v(" "),e("h3",{attrs:{id:"_2-clang-emit-llvm-ir"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-clang-emit-llvm-ir"}},[t._v("#")]),t._v(" 2. Clang emit LLVM IR")]),t._v(" "),e("h4",{attrs:{id:"input-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#input-2"}},[t._v("#")]),t._v(" Input")]),t._v(" "),e("p",[t._v("AST.")]),t._v(" "),e("h4",{attrs:{id:"output-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#output-2"}},[t._v("#")]),t._v(" Output")]),t._v(" "),e("p",[t._v("LLVM Intermediate Representation (IR).")]),t._v(" "),e("h4",{attrs:{id:"tool-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tool-2"}},[t._v("#")]),t._v(" Tool")]),t._v(" "),e("p",[t._v("Clang’s Code Generation phase.")]),t._v(" "),e("h4",{attrs:{id:"transformation-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#transformation-2"}},[t._v("#")]),t._v(" Transformation")]),t._v(" "),e("p",[t._v("Once the AST is constructed, the compiler translates it into LLVM IR."),e("br"),t._v("\nLLVM IR is a low-level, typed, static single assignment (SSA) form that is independent of any specific machine architecture."),e("br"),t._v("\nIt consists of a set of instructions operating on virtual registers, with each register assigned only once (SSA form).")]),t._v(" "),e("h4",{attrs:{id:"reason-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reason-2"}},[t._v("#")]),t._v(" Reason")]),t._v(" "),e("p",[t._v("LLVM IR is a portable, intermediate code format that enables various machine-independent optimizations.\nIt is also the bridge between different frontends (e.g., Clang, Rust) and the backend that handles machine-specific code generation.")]),t._v(" "),e("h4",{attrs:{id:"key-source-file-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-source-file-2"}},[t._v("#")]),t._v(" Key Source File")]),t._v(" "),e("p",[t._v("clang/lib/CodeGen/")]),t._v(" "),e("h4",{attrs:{id:"key-functions-classes-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-functions-classes-2"}},[t._v("#")]),t._v(" Key Functions/Classes")]),t._v(" "),e("h5",{attrs:{id:"codegenfunction-this-class-is-responsible-for-generating-llvm-ir-from-the-ast"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#codegenfunction-this-class-is-responsible-for-generating-llvm-ir-from-the-ast"}},[t._v("#")]),t._v(" CodeGenFunction: This class is responsible for generating LLVM IR from the AST.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": It traverses the AST and generates the corresponding LLVM IR."),e("br"),t._v("\nFor example, for a function definition in the AST, it creates an llvm::Function in the IR.")]),t._v(" "),e("h5",{attrs:{id:"emitfunctionbody-this-method-inside-codegenfunction-emits-the-body-of-a-function-in-ir"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#emitfunctionbody-this-method-inside-codegenfunction-emits-the-body-of-a-function-in-ir"}},[t._v("#")]),t._v(" EmitFunctionBody: This method inside CodeGenFunction emits the body of a function in IR.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": It walks over statements and expressions within the function and emits LLVM IR instructions.")]),t._v(" "),e("h5",{attrs:{id:"emitexpr-and-emitstmt-these-methods-handle-expressions-and-statements-within-the-ast-and-translate-them-into-llvm-ir"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#emitexpr-and-emitstmt-these-methods-handle-expressions-and-statements-within-the-ast-and-translate-them-into-llvm-ir"}},[t._v("#")]),t._v(" EmitExpr and EmitStmt: These methods handle expressions and statements within the AST and translate them into LLVM IR.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": EmitExpr generates LLVM IR for expressions (e.g., arithmetic operations, function calls), while EmitStmt generates IR for control-flow structures like if statements and loops.")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"ir-target-and-source-programing-language-independent"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ir-target-and-source-programing-language-independent"}},[t._v("#")]),t._v(" IR Target and Source Programing Language Independent")]),t._v(" "),e("h3",{attrs:{id:"_3-llvm-target-independent-ir-optimization"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-llvm-target-independent-ir-optimization"}},[t._v("#")]),t._v(" 3. LLVM Target Independent IR Optimization")]),t._v(" "),e("h4",{attrs:{id:"input-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#input-3"}},[t._v("#")]),t._v(" Input")]),t._v(" "),e("p",[t._v("Unoptimized LLVM IR.")]),t._v(" "),e("h4",{attrs:{id:"output-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#output-3"}},[t._v("#")]),t._v(" Output")]),t._v(" "),e("p",[t._v("Optimized LLVM IR.")]),t._v(" "),e("h4",{attrs:{id:"tool-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tool-3"}},[t._v("#")]),t._v(" Tool")]),t._v(" "),e("p",[t._v("LLVM Optimizer (opt).")]),t._v(" "),e("h4",{attrs:{id:"transformation-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#transformation-3"}},[t._v("#")]),t._v(" Transformation")]),t._v(" "),e("p",[t._v("LLVM applies a series of machine-independent optimizations to the IR, such as dead code elimination, constant propagation, inlining, and loop optimizations."),e("br"),t._v("\nThese transformations operate on the SSA form of the IR to improve performance and reduce unnecessary instructions.")]),t._v(" "),e("h4",{attrs:{id:"reason-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reason-3"}},[t._v("#")]),t._v(" Reason")]),t._v(" "),e("p",[t._v("Optimizing at the IR level allows for improvements that are independent of the target architecture, making the resulting code more efficient before it reaches machine-specific stages.")]),t._v(" "),e("h4",{attrs:{id:"key-source-files"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-source-files"}},[t._v("#")]),t._v(" Key Source Files")]),t._v(" "),e("p",[t._v("llvm/lib/Transforms/")]),t._v(" "),e("h4",{attrs:{id:"key-functions-classes-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-functions-classes-3"}},[t._v("#")]),t._v(" Key Functions/Classes:")]),t._v(" "),e("h5",{attrs:{id:"opt-the-opt-tool-runs-optimization-passes-on-the-llvm-ir"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#opt-the-opt-tool-runs-optimization-passes-on-the-llvm-ir"}},[t._v("#")]),t._v(" opt The opt tool runs optimization passes on the LLVM IR.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": opt applies a series of transformations to the IR to improve efficiency."),e("br"),t._v("\nThese transformations include passes like dead code elimination (DeadCodeElimination.cpp), inlining (InlineFunction.cpp), and constant propagation (ConstantPropagation.cpp).")]),t._v(" "),e("h5",{attrs:{id:"key-passes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-passes"}},[t._v("#")]),t._v(" Key Passes:")]),t._v(" "),e("p",[e("strong",[t._v("DeadStoreElimination")]),t._v(": Eliminates stores that are never used.\n"),e("strong",[t._v("SCCP (Sparse Conditional Constant Propagation)")]),t._v(": Optimizes based on constant values propagated through the program.\n"),e("strong",[t._v("GVN (Global Value Numbering)")]),t._v(": Removes redundant calculations.")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"target-dependent-codegen"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#target-dependent-codegen"}},[t._v("#")]),t._v(" Target Dependent Codegen")]),t._v(" "),e("h3",{attrs:{id:"_3-selectiondag-node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-selectiondag-node"}},[t._v("#")]),t._v(" 3. SelectionDAG Node"),e("br")]),t._v(" "),e("p",[t._v("SelectionDAGBuild creates SDGNode"),e("br"),t._v("\nSelectionDAGIsel goes over all IR instructions and calls "),e("strong",[t._v("SelectionDAGBuilder::visit")]),t._v(" to Dispatch them"),e("br"),t._v("\nWe can use -debug to llc or -view to get log or dump image of the graph"),e("br")]),t._v(" "),e("h3",{attrs:{id:"_4-to-emit-machine-instructions-llvm-will-legalize-the-operation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-to-emit-machine-instructions-llvm-will-legalize-the-operation"}},[t._v("#")]),t._v(" 4. To emit machine instructions, LLVM will legalize the operation"),e("br")]),t._v(" "),e("p",[t._v("Use target-specific hooks to convert all operations and types into ones that the target actually supports.\nThis is done by "),e("strong",[t._v("TargetLowering")]),t._v(". "),e("br"),t._v("\nSelectionDAGLegalize::LegalizeOp")]),t._v(" "),e("h3",{attrs:{id:"_3-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4"}},[t._v("#")]),t._v(" 3 & 4")]),t._v(" "),e("h4",{attrs:{id:"input-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#input-4"}},[t._v("#")]),t._v(" Input")]),t._v(" "),e("p",[t._v("Optimized LLVM IR.")]),t._v(" "),e("h4",{attrs:{id:"output-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#output-4"}},[t._v("#")]),t._v(" Output")]),t._v(" "),e("p",[t._v("SelectionDAG.")]),t._v(" "),e("h4",{attrs:{id:"tool-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tool-4"}},[t._v("#")]),t._v(" Tool")]),t._v(" "),e("p",[t._v("LLVM CodeGen Phase.")]),t._v(" "),e("h4",{attrs:{id:"transformation-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#transformation-4"}},[t._v("#")]),t._v(" Transformation")]),t._v(" "),e("p",[t._v("In this phase, LLVM lowers the IR into a Selection Directed Acyclic Graph (SelectionDAG)."),e("br"),t._v("\nThe SelectionDAG represents the program in terms of target-independent operations (nodes) and data dependencies (edges)."),e("br"),t._v("\nEach node in the DAG represents an operation, and the edges show data flow between these operations.")]),t._v(" "),e("h4",{attrs:{id:"reason-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reason-4"}},[t._v("#")]),t._v(" Reason")]),t._v(" "),e("p",[t._v("The SelectionDAG abstracts machine-specific details while exposing data dependencies, allowing for architecture-specific instruction selection and scheduling in a clean, optimized manner.")]),t._v(" "),e("h4",{attrs:{id:"key-source-file-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-source-file-3"}},[t._v("#")]),t._v(" Key Source File")]),t._v(" "),e("p",[t._v("llvm/lib/CodeGen/SelectionDAG/")]),t._v(" "),e("h4",{attrs:{id:"key-functions-classes-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-functions-classes-4"}},[t._v("#")]),t._v(" Key Functions/Classes")]),t._v(" "),e("h5",{attrs:{id:"selectiondagbuilder-this-class-is-responsible-for-constructing-the-selectiondag-from-the-llvm-ir"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#selectiondagbuilder-this-class-is-responsible-for-constructing-the-selectiondag-from-the-llvm-ir"}},[t._v("#")]),t._v(" SelectionDAGBuilder: This class is responsible for constructing the SelectionDAG from the LLVM IR.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": It lowers the LLVM IR instructions into nodes in the SelectionDAG."),e("br"),t._v("\nEach node in the DAG represents an operation (e.g., addition, memory load) that can later be translated into machine instructions.")]),t._v(" "),e("h5",{attrs:{id:"loweroperation-a-method-that-lowers-a-specific-llvm-ir-instruction-like-an-add-operation-to-a-corresponding-selectiondag-node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#loweroperation-a-method-that-lowers-a-specific-llvm-ir-instruction-like-an-add-operation-to-a-corresponding-selectiondag-node"}},[t._v("#")]),t._v(" LowerOperation: A method that lowers a specific LLVM IR instruction (like an add operation) to a corresponding SelectionDAG node.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": This function breaks down LLVM IR into target-independent operations within the DAG.")]),t._v(" "),e("h5",{attrs:{id:"legalizedag-ensures-that-the-dag-s-operations-conform-to-the-target-machine-s-constraints-e-g-valid-data-types-supported-instructions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#legalizedag-ensures-that-the-dag-s-operations-conform-to-the-target-machine-s-constraints-e-g-valid-data-types-supported-instructions"}},[t._v("#")]),t._v(" LegalizeDAG: Ensures that the DAG's operations conform to the target machine's constraints (e.g., valid data types, supported instructions).")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": Legalizes operations by splitting larger types into smaller ones or mapping operations to a series of simpler operations that the target can execute.")]),t._v(" "),e("h3",{attrs:{id:"_5-instruction-selection-from-sdnode-to-machinesdnode"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-instruction-selection-from-sdnode-to-machinesdnode"}},[t._v("#")]),t._v(" 5. Instruction selection from SDNode to MachineSDNode"),e("br")]),t._v(" "),e("p",[t._v("SelectionDAGISel::Select"),e("br"),t._v("\nSelectCode"),e("br"),t._v("\nThis step will create MachineSDNode, a subclass of SDNode which holds the information required to construct an actual machine instruction, but still in DAG node form.")]),t._v(" "),e("h4",{attrs:{id:"input-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#input-5"}},[t._v("#")]),t._v(" Input")]),t._v(" "),e("p",[t._v("SelectionDAG.")]),t._v(" "),e("h4",{attrs:{id:"output-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#output-5"}},[t._v("#")]),t._v(" Output")]),t._v(" "),e("p",[t._v("MachineDAG (target-specific instructions).")]),t._v(" "),e("h4",{attrs:{id:"tool-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tool-5"}},[t._v("#")]),t._v(" Tool")]),t._v(" "),e("p",[t._v("LLVM Target Lowering (Target-specific instruction selectors).")]),t._v(" "),e("h4",{attrs:{id:"transformation-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#transformation-5"}},[t._v("#")]),t._v(" Transformation")]),t._v(" "),e("p",[t._v("At this stage, the SelectionDAG is converted into a MachineDAG, where the target-independent nodes of the DAG are mapped to actual machine instructions (specific to the target architecture)."),e("br"),t._v("\nThis involves instruction selection, which translates abstract operations (like add, mul) into the corresponding machine instructions (e.g., x86 or ARM instructions).")]),t._v(" "),e("h4",{attrs:{id:"reason-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reason-5"}},[t._v("#")]),t._v(" Reason")]),t._v(" "),e("p",[t._v("The MachineDAG is essential because it ties the program’s logic to a specific machine's instruction set."),e("br"),t._v("\nThis allows for efficient use of architecture-specific features like registers, instruction pipelines, and specialized operations.")]),t._v(" "),e("h4",{attrs:{id:"key-source-file-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-source-file-4"}},[t._v("#")]),t._v(" Key Source File")]),t._v(" "),e("p",[t._v("llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp")]),t._v(" "),e("h4",{attrs:{id:"key-functions-classes-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-functions-classes-5"}},[t._v("#")]),t._v(" Key Functions/Classes:")]),t._v(" "),e("h5",{attrs:{id:"selectiondagisel-the-core-class-responsible-for-instruction-selection"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#selectiondagisel-the-core-class-responsible-for-instruction-selection"}},[t._v("#")]),t._v(" SelectionDAGISel: The core class responsible for instruction selection.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": It converts the target-independent DAG into a target-specific MachineDAG."),e("br"),t._v("\nThis involves mapping high-level operations like add to actual machine instructions for the target architecture.")]),t._v(" "),e("h5",{attrs:{id:"selectcode-this-method-performs-pattern-matching-to-select-the-most-appropriate-machine-instruction-for-each-dag-node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#selectcode-this-method-performs-pattern-matching-to-select-the-most-appropriate-machine-instruction-for-each-dag-node"}},[t._v("#")]),t._v(" SelectCode: This method performs pattern matching to select the most appropriate machine instruction for each DAG node.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": It uses target-specific information (provided in .td files) to match operations in the DAG to machine instructions.")]),t._v(" "),e("h3",{attrs:{id:"_6-scheduling-and-emitting-a-machineinstr"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-scheduling-and-emitting-a-machineinstr"}},[t._v("#")]),t._v(" 6. Scheduling and emitting a MachineInstr"),e("br")]),t._v(" "),e("p",[t._v("Translate SDNode into Machine Instructions with InstrEmitter::EmitMachineNode, emmit into MachineBasicBlock.\nHere the instruction are in linear form (MI). No DAG any more."),e("br"),t._v(" "),e("strong",[t._v("-print-machineinstrs")]),e("br"),t._v("\nStill SSA form.")]),t._v(" "),e("h4",{attrs:{id:"input-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#input-6"}},[t._v("#")]),t._v(" Input")]),t._v(" "),e("p",[t._v("MachineDAG.")]),t._v(" "),e("h4",{attrs:{id:"output-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#output-6"}},[t._v("#")]),t._v(" Output")]),t._v(" "),e("p",[t._v("A sequence of machine instructions (linear instruction stream).")]),t._v(" "),e("h4",{attrs:{id:"tool-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tool-6"}},[t._v("#")]),t._v(" Tool")]),t._v(" "),e("p",[t._v("LLVM CodeGen Scheduler.")]),t._v(" "),e("h4",{attrs:{id:"transformation-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#transformation-6"}},[t._v("#")]),t._v(" Transformation")]),t._v(" "),e("p",[t._v("The MachineDAG undergoes instruction scheduling, where the instructions are ordered in a way that respects data dependencies while maximizing performance."),e("br"),t._v("\nThis is necessary to avoid pipeline stalls, reduce instruction latency, and exploit instruction-level parallelism (ILP) in the target CPU.")]),t._v(" "),e("h4",{attrs:{id:"reason-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reason-6"}},[t._v("#")]),t._v(" Reason")]),t._v(" "),e("p",[t._v("Modern CPUs can execute multiple instructions in parallel, so careful scheduling can significantly improve performance by maximizing resource utilization (e.g., CPU pipeline, functional units).")]),t._v(" "),e("h4",{attrs:{id:"key-source-files-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-source-files-2"}},[t._v("#")]),t._v(" Key Source Files")]),t._v(" "),e("p",[t._v("llvm/lib/CodeGen/ScheduleDAG/, llvm/lib/CodeGen/MachineScheduler.cpp")]),t._v(" "),e("h4",{attrs:{id:"key-functions-classes-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-functions-classes-6"}},[t._v("#")]),t._v(" Key Functions/Classes:")]),t._v(" "),e("h5",{attrs:{id:"scheduledaginstrs-this-class-represents-the-dag-used-for-scheduling-machine-instructions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#scheduledaginstrs-this-class-represents-the-dag-used-for-scheduling-machine-instructions"}},[t._v("#")]),t._v(" ScheduleDAGInstrs: This class represents the DAG used for scheduling machine instructions.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": It is responsible for reordering the instructions within the MachineDAG to avoid pipeline stalls, minimize instruction latency, and make use of instruction-level parallelism.")]),t._v(" "),e("h5",{attrs:{id:"schedulemachinebasicblock-this-method-schedules-the-instructions-in-a-machine-basic-block-based-on-data-dependencies-and-resource-constraints"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#schedulemachinebasicblock-this-method-schedules-the-instructions-in-a-machine-basic-block-based-on-data-dependencies-and-resource-constraints"}},[t._v("#")]),t._v(" ScheduleMachineBasicBlock: This method schedules the instructions in a machine basic block based on data dependencies and resource constraints.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": It takes the MachineDAG, considers the target architecture’s constraints, and reorders instructions for optimal performance.")]),t._v(" "),e("h3",{attrs:{id:"_7-register-allocation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-register-allocation"}},[t._v("#")]),t._v(" 7. Register Allocation"),e("br")]),t._v(" "),e("p",[t._v("For instructions that can only support fixed registers, it is already allocated. Here the virtual registers are allocated into physical registers. This assignment is done by X86DAGToDAGISel::Select."),e("br"),t._v("\nAfter this, another round of optimization is conducted, TargetPassConfig::addMachinePasses.")]),t._v(" "),e("h4",{attrs:{id:"input-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#input-7"}},[t._v("#")]),t._v(" Input")]),t._v(" "),e("p",[t._v("Machine Instructions with virtual registers.")]),t._v(" "),e("h4",{attrs:{id:"output-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#output-7"}},[t._v("#")]),t._v(" Output")]),t._v(" "),e("p",[t._v("Machine instructions with physical registers.")]),t._v(" "),e("h4",{attrs:{id:"tool-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tool-7"}},[t._v("#")]),t._v(" Tool")]),t._v(" "),e("p",[t._v("LLVM Register Allocator.")]),t._v(" "),e("h4",{attrs:{id:"transformation-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#transformation-7"}},[t._v("#")]),t._v(" Transformation")]),t._v(" "),e("p",[t._v("In this phase, virtual registers (which are unlimited in the IR and DAG forms) are mapped to actual physical registers of the target architecture. The allocator decides which values stay in registers and which are spilled to memory if there aren’t enough registers available.")]),t._v(" "),e("h4",{attrs:{id:"reason-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reason-7"}},[t._v("#")]),t._v(" Reason")]),t._v(" "),e("p",[t._v("Physical registers are a limited resource, so register allocation is critical to ensure the efficient execution of the program on the target hardware.")]),t._v(" "),e("h4",{attrs:{id:"key-source-files-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-source-files-3"}},[t._v("#")]),t._v(" Key Source Files")]),t._v(" "),e("p",[t._v("llvm/lib/CodeGen/RegAlloc*")]),t._v(" "),e("h4",{attrs:{id:"key-functions-classes-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-functions-classes-7"}},[t._v("#")]),t._v(" Key Functions/Classes:")]),t._v(" "),e("h5",{attrs:{id:"registerallocator-a-generic-class-for-performing-register-allocation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#registerallocator-a-generic-class-for-performing-register-allocation"}},[t._v("#")]),t._v(" RegisterAllocator: A generic class for performing register allocation.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": It allocates physical registers to virtual registers used in the MachineDAG. If not enough physical registers are available, it spills some of the values to memory.")]),t._v(" "),e("h5",{attrs:{id:"linearscan-and-greedy-these-are-specific-register-allocation-algorithms-provided-by-llvm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linearscan-and-greedy-these-are-specific-register-allocation-algorithms-provided-by-llvm"}},[t._v("#")]),t._v(" LinearScan and Greedy: These are specific register allocation algorithms provided by LLVM.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": Greedy attempts to assign physical registers in a way that minimizes spills, while LinearScan allocates registers in a simpler but potentially less optimal way.")]),t._v(" "),e("h3",{attrs:{id:"_8-from-machineinstruction-to-mcinst"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-from-machineinstruction-to-mcinst"}},[t._v("#")]),t._v(" 8. From MachineInstruction to MCinst")]),t._v(" "),e("p",[t._v("JIT: AsmPrinter::EmitInstruction"),e("br"),t._v("\nObj: ObjectStreamer::EmitInstruction"),e("br")]),t._v(" "),e("h4",{attrs:{id:"input-8"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#input-8"}},[t._v("#")]),t._v(" Input")]),t._v(" "),e("p",[t._v("Machine Instructions with physical registers.")]),t._v(" "),e("h4",{attrs:{id:"output-8"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#output-8"}},[t._v("#")]),t._v(" Output")]),t._v(" "),e("p",[t._v("Assembly code.")]),t._v(" "),e("h4",{attrs:{id:"tool-8"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tool-8"}},[t._v("#")]),t._v(" Tool")]),t._v(" "),e("p",[t._v("LLVM AsmPrinter.")]),t._v(" "),e("h4",{attrs:{id:"transformation-8"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#transformation-8"}},[t._v("#")]),t._v(" Transformation")]),t._v(" "),e("p",[t._v("Finally, the machine instructions are converted into assembly code, which is a human-readable form of the machine code. This step may also involve additional final optimizations (e.g., peephole optimizations).")]),t._v(" "),e("h4",{attrs:{id:"reason-8"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reason-8"}},[t._v("#")]),t._v(" Reason")]),t._v(" "),e("p",[t._v("Assembly is a textual representation of machine code, which can then be assembled into binary instructions by the assembler.")]),t._v(" "),e("h4",{attrs:{id:"key-source-file-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-source-file-5"}},[t._v("#")]),t._v(" Key Source File")]),t._v(" "),e("p",[t._v("llvm/lib/CodeGen/AsmPrinter/")]),t._v(" "),e("h4",{attrs:{id:"key-functions-classes-8"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key-functions-classes-8"}},[t._v("#")]),t._v(" Key Functions/Classes")]),t._v(" "),e("h5",{attrs:{id:"asmprinter-this-class-converts-machine-instructions-into-textual-assembly"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#asmprinter-this-class-converts-machine-instructions-into-textual-assembly"}},[t._v("#")]),t._v(" AsmPrinter: This class converts machine instructions into textual assembly.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": It traverses the list of machine instructions and prints the corresponding assembly syntax for the target architecture.")]),t._v(" "),e("h5",{attrs:{id:"emitinstruction-this-method-in-asmprinter-prints-an-individual-machine-instruction"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#emitinstruction-this-method-in-asmprinter-prints-an-individual-machine-instruction"}},[t._v("#")]),t._v(" EmitInstruction: This method in AsmPrinter prints an individual machine instruction.")]),t._v(" "),e("p",[e("strong",[t._v("Function")]),t._v(": It translates machine-specific instructions into their corresponding assembly code.")]),t._v(" "),e("h3",{attrs:{id:"_9-build-llvm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-build-llvm"}},[t._v("#")]),t._v(" 9. Build LLVM")]),t._v(" "),e("p",[t._v("create build&cd build"),e("br"),t._v('\ncmake -S llvm -B . -DCMAKE_BUILD_TYPE=Debug -DLLVM_TARGETS_TO_BUILD="MSP430;RISCV" ../llvm'),e("br"),t._v("\nmake -j 8"),e("br")]),t._v(" "),e("h4",{attrs:{id:"how-to-build-lc3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#how-to-build-lc3"}},[t._v("#")]),t._v(" How to build LC3")]),t._v(" "),e("p",[t._v('cmake -S llvm -B . -DCMAKE_BUILD_TYPE=Debug  -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD="LC3" ../llvm'),e("br")])])}),[],!1,null,null,null);e.default=i.exports}}]);