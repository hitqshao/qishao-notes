(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{461:function(e,t,a){"use strict";a.r(t);var s=a(5),r=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("ol",[t("li",[e._v("[117] Observations and Opportunities in Architecting Shared Virtual Memory for Heterogeneous Systems üëç üëç üëç üëç üë¥")]),e._v(" "),t("li",[e._v("[68] Sheduling Page Table Walks for Irregular GPU Applications")])]),e._v(" "),t("hr"),e._v(" "),t("h1",{attrs:{id:"_2-sheduling-page-table-walks-for-irregular-gpu-applications"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-sheduling-page-table-walks-for-irregular-gpu-applications"}},[e._v("#")]),e._v(" 2. Sheduling Page Table Walks for Irregular GPU Applications")]),e._v(" "),t("ul",[t("li",[e._v("better forward progress is achieved by prioritizing translation requests from the instructions that require less work to service their\naddress translation needs.")]),e._v(" "),t("li",[e._v("batching walk requests originating from the same SIMD instruction could reduce unnecessary stalls.")])]),e._v(" "),t("h2",{attrs:{id:"background"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" Background")]),e._v(" "),t("p",[e._v("real hardware demonstrated that such divergent memory accesses can slow down an irregular GPU application by up to 3.7-4√ó due to address translation overheads alone [5]."),t("br"),e._v("\nThe study found that the negative impact of divergence could be greater on address translation than on the caches.")]),e._v(" "),t("p",[e._v("Due to the lack of sufficient spatial locality in such irregular applications, these requests often miss in TLBs, each generating a page table walk request.")]),e._v(" "),t("p",[e._v("we show that the order in which page table walk requests are serviced is also critical.")]),e._v(" "),t("p",[t("em",[e._v("First")]),e._v(", the number of page table walks generated due to the execution of a single SIMD memory instruction can vary widely based on how many distinct pages the instruction accesses and the TLB hits/misses it generates.\na completely divergent SIMD instruction can generate page table walk requests equal to the number of workitems in the wavefront (here, 64)."),t("br"),e._v(" "),t("em",[e._v("Second")]),e._v(", each page walk may itself need anywhere between one to four memory requests to complete."),t("br"),e._v("\nThis happens due to hits/misses in page walk caches (PWCs) that store recently-used upperlevel entries of four-level page tables (d")]),e._v(" "),t("h2",{attrs:{id:"idea"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#idea"}},[e._v("#")]),e._v(" Idea")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/580b28d0-71f8-428a-852a-514204e070ed",alt:"image"}})]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/56b3c46e-9db9-4b8e-bcf1-7066487b4d51",alt:"image"}})])])}),[],!1,null,null,null);t.default=r.exports}}]);