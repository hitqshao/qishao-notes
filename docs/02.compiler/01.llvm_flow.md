---
title: llvm flow
date: 2023-11-21
permalink: /pages/000001/
---

llvm front end demo
Notes from **Life of an instruction in LLVM**
https://blog.llvm.org/2012/11/life-of-instruction-in-llvm.html

---

## Programing Language Dependent
### 1. Clang parser will build an Abstract Syntax Tree(AST) 

#### Input
High-level source code (e.g., C, C++).
#### Output
An AST, which is a tree structure representing the syntactic structure of the source code
#### Tool
Clang Frontend
#### Transformation
The compiler’s frontend (Clang in LLVM) parses the source code and constructs an AST.\
The AST captures the hierarchical structure of the program based on grammar rules (e.g., function definitions, statements, expressions).
#### Reason
The AST is closely tied to the original source code and allows easy analysis and checking of syntactic correctness.\
It serves as a starting point for semantic analysis (e.g., type checking, variable scoping) before code generation.
#### Key Source File
clang/lib/AST/
#### Key Functions/Classes
##### ParseAST
The function responsible for initiating the parsing of source code to generate an Abstract Syntax Tree (AST).\
**Function**: This function takes the parsed tokens from the lexer and generates the AST by applying grammar rules.\
It processes the input source code and organizes it into hierarchical structures like functions, expressions, and statements.
#### Sema
The Sema class in Clang performs semantic analysis on the AST.\
**Function**: After parsing the AST, Sema checks the semantic validity of the code, ensuring things like proper type usage, function declarations, and scope resolution.

### 2. Clang emit LLVM IR
#### Input
AST.
#### Output
LLVM Intermediate Representation (IR).
#### Tool
Clang’s Code Generation phase.
#### Transformation
Once the AST is constructed, the compiler translates it into LLVM IR.\
LLVM IR is a low-level, typed, static single assignment (SSA) form that is independent of any specific machine architecture.\
It consists of a set of instructions operating on virtual registers, with each register assigned only once (SSA form).
#### Reason
LLVM IR is a portable, intermediate code format that enables various machine-independent optimizations.
It is also the bridge between different frontends (e.g., Clang, Rust) and the backend that handles machine-specific code generation.
#### Key Source File
clang/lib/CodeGen/
#### Key Functions/Classes
##### CodeGenFunction: This class is responsible for generating LLVM IR from the AST.
**Function**: It traverses the AST and generates the corresponding LLVM IR.\
For example, for a function definition in the AST, it creates an llvm::Function in the IR.
##### EmitFunctionBody: This method inside CodeGenFunction emits the body of a function in IR.
**Function**: It walks over statements and expressions within the function and emits LLVM IR instructions.
##### EmitExpr and EmitStmt: These methods handle expressions and statements within the AST and translate them into LLVM IR.
**Function**: EmitExpr generates LLVM IR for expressions (e.g., arithmetic operations, function calls), while EmitStmt generates IR for control-flow structures like if statements and loops.

---

## IR Target and Source Programing Language Independent

### 3. LLVM Target Independent IR Optimization
#### Input
Unoptimized LLVM IR.
#### Output
Optimized LLVM IR.
#### Tool
LLVM Optimizer (opt).
#### Transformation
LLVM applies a series of machine-independent optimizations to the IR, such as dead code elimination, constant propagation, inlining, and loop optimizations.\
These transformations operate on the SSA form of the IR to improve performance and reduce unnecessary instructions.
#### Reason
Optimizing at the IR level allows for improvements that are independent of the target architecture, making the resulting code more efficient before it reaches machine-specific stages.
#### Key Source Files
llvm/lib/Transforms/
#### Key Functions/Classes:
##### opt The opt tool runs optimization passes on the LLVM IR.
**Function**: opt applies a series of transformations to the IR to improve efficiency.\
These transformations include passes like dead code elimination (DeadCodeElimination.cpp), inlining (InlineFunction.cpp), and constant propagation (ConstantPropagation.cpp).
##### Key Passes:
**DeadStoreElimination**: Eliminates stores that are never used.
**SCCP (Sparse Conditional Constant Propagation)**: Optimizes based on constant values propagated through the program.
**GVN (Global Value Numbering)**: Removes redundant calculations.

---

## Target Dependent

### 3. SelectionDAG Node<br/>
   SelectionDAGBuild creates SDGNode<br/>
   SelectionDAGIsel goes over all IR instructions and calls SelectionDAGBuilder::visit to Dispatch them<br/>
   We can use -debug or -view to get log or dump image of the graph<br/>
### 4. To emit machine instructions, LLVM will legalize the operation<br/>
   Use target-specific hooks to convert all operations and types into ones that the target actually supports.
   This is done by **TargetLowering**. <br/>
   SelectionDAGLegalize::LegalizeOp
### 5. Instruction selection from SDNode to MachineSNDode<br/>
   SelectionDAGISel::Select<br/>
   SelectCode<br/>
   This step will create MachineSDNode, a subclass of SDNode which holds the information required to construct an actual machine instruction, but still in DAG node form. 
### 6. Scheduling and emitting a MachineInstr<br/>
   Translate SDNode into Machine Instructions with InstrEmitter::EmitMachineNode, emmit into MachineBasicBlock.
   Here the instruction are in linear form (MI). No DAG any more.<br/>
   **-print-machineinstrs**<br/>
   Still SSA form.
### 7. Register Allocation<br/>
   For instructions that can only support fixed registers, it is already allocated. Here the virtual registers are allocated into physical registers. This assignment is done by X86DAGToDAGISel::Select.<br/>
   After this, another round of optimization is conducted, TargetPassConfig::addMachinePasses.
### 8. From MachineInstruction to MCinst
   JIT: AsmPrinter::EmitInstruction<br/>
   Obj: ObjectStreamer::EmitInstruction<br/>

### 9. Build LLVM
create build&cd build<br/>
cmake -S llvm -B . -DCMAKE_BUILD_TYPE=Debug -DLLVM_TARGETS_TO_BUILD="MSP430;RISCV" ../llvm<br/>
make -j 8<br/>
#### How to build LC3
cmake -S llvm -B . -DCMAKE_BUILD_TYPE=Debug  -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD="LC3" ../llvm<br/>

