---
title: Writing TinyRISCV Backend
output:
  html_document:
    code_folding: hide
date: 2024-10-09
permalink: /pages/000008/
---

### 1. 2024-10-08

Create the Framework of Basic Backend

![Screenshot from 2024-10-09 16-32-52](https://github.com/user-attachments/assets/a2e5d898-25e0-427d-abe4-6a79dd2eb560)

Only framework is added, except InstrFormats.td, InstrInfo.td and RegisterInfo.td.

Above tablegen files are copied from https://github.com/rhysd/toy-riscv-backend. These tablegen files are uniform for riscv-compatible backend compilers.

### 2. 2024-10-09

When I try to compile sometest.ll with above backend, error:

```console
llvm/lib/CodeGen/LLVMTargetMachine.cpp:47:
void llvm::LLVMTargetMachine::initAsmInfo(): Assertion `MRI && "Unable to create reg info"' failed
```

#### Claude explains why MC Register Info is needed
The reason is that MCRegisterInfo is not created.

The function createTinyRISCVMCRegisterInfo is responsible for creating and initializing the MCRegisterInfo object for your TinyRISCV target.\
This object provides essential information about the registers available in your target architecture, which is crucial for various stages of code generation and assembly.

Key Functions of createTinyRISCVMCRegisterInfo
1. Register Initialization:\
It initializes the register information for the TinyRISCV target, including the mapping of register names to register numbers and any special properties of the registers.
2. Callee-Saved Registers:\
The MCRegisterInfo object typically includes information about which registers are callee-saved, which is important for function call conventions and stack management.
4. Register Aliases:\
It may define any register aliases, which are alternative names or numbers for the same physical register.
5. Register Classes:\
The function helps define register classes, which group registers with similar characteristics (e.g., general-purpose registers).
6. Integration with LLVM:\
By registering the MCRegisterInfo with the LLVM target registry, it ensures that the rest of the LLVM infrastructure can access and use the register information for tasks like instruction selection, register allocation, and assembly printing.

Example Implementation
Here's a typical implementation of createTinyRISCVMCRegisterInfo:

```
static MCRegisterInfo *createTinyRISCVMCRegisterInfo(const Triple &TT) {
  MCRegisterInfo *X = new MCRegisterInfo();
  InitTinyRISCVMCRegisterInfo(X, /* Return address register number */);
  return X;
}

```

**InitTinyRISCVMCRegisterInfo** \
This function, usually generated by TableGen, initializes the MCRegisterInfo object with the register definitions specified in your target's TableGen files.

**Return Address Register** \
The function often takes a parameter specifying the register used for the return address, which is important for call and return instructions.

By ensuring that createTinyRISCVMCRegisterInfo is correctly implemented and registered, you provide the necessary register information to the LLVM backend, enabling it to generate and manipulate machine code effectively for your TinyRISCV target.

#### Debug

Spend lots of time on debugs namespace tinyriscv issue

root cause is that:

we need to include TinyRISCVGenRegisterInfo.inc in both *TinyRISCVMCTargetDesc.h* and *TinyRISCVMCTargetDesc.cpp*.

Once for define, another for declare.

### 3. 2024-10-12

```
llc  -debug -debug-pass=Structure -march=tinyriscv
tinyriscv_simpletest.ll
-o tinyriscv_addition.s

Failed:
llc: error: target does not support generation of this file type
```

Try to solve this issue, might due to missing of addPasses in TargetMachine.h/cpp.

when subtarget is not implemented:

```
bool runOnFunction(Function &F) override {
  auto *TM = &getAnalysis<TargetPassConfig>().getTM<TargetMachine>();
  auto *TLI = TM->getSubtargetImpl(F)->getTargetLowering();
  return runImpl(F, *TLI);
}

static bool runImpl(Function &F, const TargetLowering &TLI) {
.....
}
```

### 4. 2024-10-13

Forget to add getFrameLowering in *TargetMachine.h
```
#11 0x00007e10aebdbd7a llvm::TargetLowering::LowerCall(llvm::TargetLowering::CallLoweringInfo&, llvm::SmallVectorImpl<llvm::SDValue>&) const ...TargetLowering.h:4770:5
#12 0x00007e10ad58b07b llvm::SelectionDAGISel::LowerArguments(llvm::Function const&) ...SelectionDAGBuilder.cpp:11673:46
#13 0x00007e10ad679308 llvm::SelectionDAGISel::SelectAllBasicBlocks(llvm::Function const&) ...CodeGen/SelectionDAG/SelectionDAGISel.cpp:1648:19
```

This is the bug that when called getNumRegisters() in TargetLowering.h, the NumRegisterForVT[VT.getSimpleVT().SimpleTy] returns 0.

The NumRegisterForVT is not initialized in our case.

this is initialized by calling **computeRegisterProperties** in TinyRISCVTargetLowering, which does not called before solving this bug.
