---
title: Getting Started with LLVM Core Libraries-Notes Chap6 Backend
date: 2023-11-21
permalink: /pages/000003/
---
### Chap6. The Backend
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/a5566aac-5d9f-40c4-810b-ec6572a3e94f)

**White box** Essential
**Gray Block** For generated code efficiency
#### 1. Instructon Selection<br>
  * Convert IR to target-specific SelectionDAG(Directed Acyclic Graph)
    - Block->DAG
    - Instruction->Node
    - Edge contains dataflow dependence and control dependence and glue.
  * LLVM use DAG to employ tree-based pattern-matching instruction selection.
  * IN the end of this phase, IR node are converted to target-machine(machine instructions) nodes.
#### 2. Pre-register Allocation(RA) scheduling,the first instruction scheduling.<br>
  * This is to explore instruction-level parallelism
  * The instructions are converted to MachineInstr three-address representation.
#### 3. Reguster Allocation<br>
#### 4. Post-register Allocation(RA) Instruction Scheduling, the second instruction scheduling
  * Now we have real register information, we can combine information of extra hazards and delays of real register to opmitize code.
#### 5. Code Emission
  * Convert MachineInstr to MCInst
  * Emit Assembly Code
  * Emit Binary blobs to object code format 

### Using the backend tools
```
llc *bc -o *.s
llc *.bc -filetype=obj -o *.o

llc *.bc -march=mips -filetype=obj -o *.o

// how march options
llc -version
```

### Learning backend struture

* CodeGen: Instruction selection, scheduler,register allocation
* MC: assembly parser, disassembler
* TableGen
* Target/*.cpp *.h *.td
  
Notice:
**IselDAGtoDAG is for instruction selection.** <br>
**IselLowering is for Selection DAG Node lowering** <br>
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/723f687b-0303-4add-89ea-5fe88676049c)

### Knowing backend libraries
* <Target>AsmParser.a
* <Target>AsmPrinter.a
* <Target>CodeGen.a
  - majority of the target-dependent functionality of the backend, as followingï¼š
  - specific register handling rules, instruction selection, and scheduling
* <Target>Desc.a
  -  low-level MC infrastructure and is responsible for registering target-specific MC objects such as MCCodeEmitter
* <Target>Info.a
* <Target>Disassembler.a

### Learning how to use TableGen for LLVM backends

* instruction formats,
* instructions,
* registers,
* pattern-matching DAGs,
* instruction selection matching order,
* calling conventions,
* target CPU properties (supported Instruction Set Architecture (ISA) features and processor families).

insns.td
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/e85b4512-f6d2-475d-bb4b-7fdb6a2bf8e8)

Generate code using llvm-tblgen
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/843b44f4-7d07-470d-85f8-5ff7c3aa167d)

**Target Properties: <Target>.td**<br>
**Registers: <Target>RegisterInfo.td** <br>
```
$ cd <llvm_source>/lib/Target/X86
$ llvm-tblgen -gen-register-info X86.td -I ../../../include
```
**Instruction format: <Target>InstrFormat.td** <br>
**Instructions: <Target>InstrInfo.td** <br>
```
include/llvm/Target/Target.td
```
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/89ae29d2-9a4d-4466-98a9-c1af119fb056)


dag in the above picture represents selectDAG for opcodes, registers or constants during instruction selection phase.<br>
```
SparcInstrInfo.td
```
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/6b733913-3755-4a66-acb0-a78958033216)

We can get how the template parameters are assigned to class Instruction.
* OutOperandList
* InOperandList
* AsmString
* Pattern

```
cd <llvm_sources>/lib/Target/Sparc
llvm-tblgen -print-records Sparc.td -I ../../../include | grep XNORrr -A 10
```
**The difference between the first and second need to be checked.**
* <Target>GenDAGISel.inc 
* <Target>GenInstrInfo.inc
* <Target>GenAsmWriter.inc
* <Target>GenCodeEmitter.inc
* <Target>GenDisassemblerTables.inc
* <Target>GenAsmMatcher.inc

### Instruction Selection Phase
LLVM IR -> SelectionDAG(SDNode)

1) Create DAG, in which node carry IR op
2) Nodes go through lowering, DAG combiner, and legalization phases.
3) Instruction selection perform DAG-to-DAG conversion, using node pattern matching and transforms SelectionDAG node into nodes representing target instructions.

**Most expensive ones in backend**

#### SelectionDAG class
* DAG for each basic block
* SDNode for instruction or operand
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/db628254-20e9-4df5-9748-cea3770dd65a)

* The black arrows represent regular edges showing a dataflow dependence.
* The dashed blue arrows represent non-dataflow chains that exist to enforce order between two otherwise unrelated instructions.
* The red edge guarantees that its adjacent nodes must be glued together

Please notice:
* CopyFromReg: This is for getting value out of scope.
* CopyToReg: **This node copies a value to a specific register without supplying any concrete value for other nodes to consume.**

### Lowering

![image](https://github.com/hitqshao/qishao-notes/assets/23403286/7c647ecf-0ad6-4540-896c-fc2da6c760c5)

1) SelectionDAGBuilder in SelectionDAGIsel.cpp visits every fuction and creates SelectionDAG for each basic block
2) During 1), special IR such as call and ret needs **TargetLowering** class for the first time for info like: pass call arg and how to return.
3) Only a smalle subset are lowered in this way. Majority are matched and replaces at **instruction selection.**

>For instance, in SelectionDAG from sum.bc, the X86TargetLowering::LowerReturn() method (see lib/Target/X86/X86ISelLowering.cpp) is used to lower the IR ret instruction.
While doing this, it generates the X86ISD::RET_FLAG node, which copies the function result to EAX a-target-specific way to handle the function return.

