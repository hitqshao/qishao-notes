---
title: Getting Started with LLVM Core Libraries-Notes Chap6 Backend
date: 2023-11-21
permalink: /pages/000003/
---
### Chap6. The Backend
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/a5566aac-5d9f-40c4-810b-ec6572a3e94f)

**White box** Essential
**Gray Block** For generated code efficiency
#### 1. Instructon Selection<br>
  * Convert IR to target-specific SelectionDAG(Directed Acyclic Graph)
    - Block->DAG
    - Instruction->Node
    - Edge contains dataflow dependence and control dependence and glue.
  * LLVM use DAG to employ tree-based pattern-matching instruction selection.
  * IN the end of this phase, IR node are converted to target-machine(machine instructions) nodes.
#### 2. Pre-register Allocation(RA) scheduling,the first instruction scheduling.<br>
  * This is to explore instruction-level parallelism
  * The instructions are converted to MachineInstr three-address representation.
#### 3. Reguster Allocation<br>
#### 4. Post-register Allocation(RA) Instruction Scheduling, the second instruction scheduling
  * Now we have real register information, we can combine information of extra hazards and delays of real register to opmitize code.
#### 5. Code Emission
  * Convert MachineInstr to MCInst
  * Emit Assembly Code
  * Emit Binary blobs to object code format 

### 1. Using the backend tools
```
llc *bc -o *.s
llc *.bc -filetype=obj -o *.o

llc *.bc -march=mips -filetype=obj -o *.o

// how march options
llc -version
```

### 2. Learning backend struture

* CodeGen: Instruction selection, scheduler,register allocation
* MC: assembly parser, disassembler
* TableGen
* Target/*.cpp *.h *.td
  
Notice:
**IselDAGtoDAG is for instruction selection.** <br>
**IselLowering is for Selection DAG Node lowering** <br>

![image](https://github.com/hitqshao/qishao-notes/assets/23403286/723f687b-0303-4add-89ea-5fe88676049c)

### 3. Knowing backend libraries
* <Target>AsmParser.a
* <Target>AsmPrinter.a
* <Target>CodeGen.a
  - majority of the target-dependent functionality of the backend, as followingï¼š
  - specific register handling rules, instruction selection, and scheduling
* <Target>Desc.a
  -  low-level MC infrastructure and is responsible for registering target-specific MC objects such as MCCodeEmitter
* <Target>Info.a
* <Target>Disassembler.a

### 4. Learning how to use TableGen for LLVM backends

* instruction formats,
* instructions,
* registers,
* pattern-matching DAGs,
* instruction selection matching order,
* calling conventions,
* target CPU properties (supported Instruction Set Architecture (ISA) features and processor families).

insns.td
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/e85b4512-f6d2-475d-bb4b-7fdb6a2bf8e8)

Generate code using llvm-tblgen
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/843b44f4-7d07-470d-85f8-5ff7c3aa167d)

**Target Properties: <Target>.td**<br>
**Registers: <Target>RegisterInfo.td** <br>
```
$ cd <llvm_source>/lib/Target/X86
$ llvm-tblgen -gen-register-info X86.td -I ../../../include
```
**Instruction format: <Target>InstrFormat.td** <br>
**Instructions: <Target>InstrInfo.td** <br>
```
include/llvm/Target/Target.td
```
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/89ae29d2-9a4d-4466-98a9-c1af119fb056)


dag in the above picture represents selectDAG for opcodes, registers or constants during instruction selection phase.<br>
```
SparcInstrInfo.td
```
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/6b733913-3755-4a66-acb0-a78958033216)

We can get how the template parameters are assigned to class Instruction.
* OutOperandList
* InOperandList
* AsmString
* Pattern

```
cd <llvm_sources>/lib/Target/Sparc
llvm-tblgen -print-records Sparc.td -I ../../../include | grep XNORrr -A 10
```
**The difference between the first and second need to be checked.**
* <Target>GenDAGISel.inc 
* <Target>GenInstrInfo.inc
* <Target>GenAsmWriter.inc
* <Target>GenCodeEmitter.inc
* <Target>GenDisassemblerTables.inc
* <Target>GenAsmMatcher.inc

### 5. Instruction Selection Phase
LLVM IR -> SelectionDAG(SDNode)

1) Create DAG, in which node carry IR op
2) Nodes go through lowering, DAG combiner, and legalization phases.
3) Instruction selection perform DAG-to-DAG conversion, using node pattern matching and transforms SelectionDAG node into nodes representing target instructions.

**Most expensive ones in backend**

#### 5.1 SelectionDAG class
* DAG for each basic block
* SDNode for instruction or operand
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/db628254-20e9-4df5-9748-cea3770dd65a)

* The black arrows represent regular edges showing a dataflow dependence.
* The dashed blue arrows represent non-dataflow chains that exist to enforce order between two otherwise unrelated instructions.
* The red edge guarantees that its adjacent nodes must be glued together

Please notice:
* CopyFromReg: This is for getting value out of scope.
* CopyToReg: **This node copies a value to a specific register without supplying any concrete value for other nodes to consume.**

### 6. Lowering

![image](https://github.com/hitqshao/qishao-notes/assets/23403286/7c647ecf-0ad6-4540-896c-fc2da6c760c5)

1) SelectionDAGBuilder in SelectionDAGIsel.cpp visits every fuction and creates SelectionDAG for each basic block
2) During 1), special IR such as call and ret needs **TargetLowering** class for the first time for info like: pass call arg and how to return.
3) Only a smalle subset are lowered in this way. Majority are matched and replaces at **instruction selection.**

> For instance, in SelectionDAG from sum.bc, the X86TargetLowering::LowerReturn() method (see lib/Target/X86/X86ISelLowering.cpp) is used to lower the IR ret instruction.<br>
> While doing this, it generates the X86ISD::RET_FLAG node, which copies the function result to EAX a-target-specific way to handle the function return.

### 7. DAG Combine and legalization
* DAG Combine
  - Optimization for simpler code
  -  Target Independent: lib/CodeGen/SelectionDAG/DAGCombiner.cpp
  -  Target Dependnet: lib/Target/<Target_Name>/<Target>ISelLowering.cpp setTargetDAGCombine()
```
setTargetDAGCombine({ISD::SDIVREM, ISD::UDIVREM, ISD::SELECT, ISD::AND,
                       ISD::OR, ISD::ADD, ISD::SUB, ISD::AssertZext, ISD::SHL});

static SDValue performADDCombine(SDNode *N, SelectionDAG &DAG,
                                 TargetLowering::DAGCombinerInfo &DCI,
                                 const MipsSubtarget &Subtarget) {
  ...
  // (add v0, (add v1, abs_lo(tjt))) => (add (add v0, v1), abs_lo(tjt))
  SDValue Add = N->getOperand(1);

  if (Add.getOpcode() != ISD::ADD)
    return SDValue();

  SDValue Lo = Add.getOperand(1);
  ...
  EVT ValTy = N->getValueType(0);
  SDLoc DL(N);

  SDValue Add1 = DAG.getNode(ISD::ADD, DL, ValTy, N->getOperand(0),
                             Add.getOperand(0));
  return DAG.getNode(ISD::ADD, DL, ValTy, Add1, Lo);
}
```
* Legalization
 - Support legal types: scalar: promote, expand, soften. vec split, scalarized or widened
 - Also it can be customized

**Promote**
**Expand(library call)**
**Custom**
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/608efd69-88b3-45ca-b854-b9077c5853db)

### 8. DAG-to-DAG instruction selection

Transform target-independent nodes to target-specific nodes by using pattern matching.

**CopyToReg, CopyFromReg and Register** nodes are untouched until **Register Allocation**.
![image](https://github.com/hitqshao/qishao-notes/assets/23403286/e7221d4d-3e7d-4d32-bdb9-4c4d07c22b76)

#### 8.1 Pattern Matching
```
lib/Target/Sparc/SparcISelDAGToDAG.cpp

Select()  in SelectionDAGISel subclass
```

Select():
* receive an SDNode parameter to be matched
* return SDNnode value representing a phycical instruction

Selection() will call TableGen generateed SelectCode method.<br>
TableGen also contains MatcherTable, mapping **ISD and <Target>ISD** to **physical-instruction node**.<br>
This table is generated by <Target>InstrInfo.td<br>
The table are contained in <build_dir>/lib/Target/Sparc/SparcGenDAGISel.inc.<br>

We can add other customized matching code prior to selectCode().

CurDAG->getMachineNode() will create a node with phsycial instruction SP::SPAri
CurDAG->SelectNodeTo() will create an instruction node and changes all use of * result to point to the "Opcode" result.

```
void SparcDAGToDAGISel::Select(SDNode *N) {
  ...
  case ISD::UDIV: {
    // sdivx / udivx handle 64-bit divides.
    if (N->getValueType(0) == MVT::i64)
      break;
    // FIXME: should use a custom expander to expose the SRA to the dag.
    SDValue DivLHS = N->getOperand(0);
    SDValue DivRHS = N->getOperand(1);

    // Set the Y register to the high-part.
    SDValue TopPart;
    if (N->getOpcode() == ISD::SDIV) {
      TopPart = SDValue(CurDAG->getMachineNode(SP::SRAri, dl, MVT::i32, DivLHS,
                                   CurDAG->getTargetConstant(31, dl, MVT::i32)),
                        0);
    } else {
      TopPart = CurDAG->getRegister(SP::G0, MVT::i32);
    }
    TopPart = CurDAG->getCopyToReg(CurDAG->getEntryNode(), dl, SP::Y, TopPart,
                                   SDValue())
                  .getValue(1);

    // FIXME: Handle div by immediate.
    unsigned Opcode = N->getOpcode() == ISD::SDIV ? SP::SDIVrr : SP::UDIVrr;
    CurDAG->SelectNodeTo(N, Opcode, MVT::i32, DivLHS, DivRHS, TopPart);
    return;
  }
  }

  SelectCode(N);
}
```

#### 8.2 Visualizing the instruction selection process

| llc      | Phase |
| ----------- | ----------- |
| -view-dag-combine1-dags      | Before DAG combine 1      |
| -view-legalize-types-dags    | Before legalize type        |
| -view-dag-combine-lt-dags    | After legalize type 2 and before DAG combine|
| -view-legalize-dags          | Before legalization|
| -view-dag-combine2-dags      | Before DAG combine 2|
| -view-isel-dags              | Before instruction selection|
| -view-sched-dags             | After instruction selection and before scheduling|

### 9. Scheduler

Pre-register allocation works on SelectionDAG nodes(SDNodes).<br>

<llvm_source>/ lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp

Different Algorithms: llc -pre-RA-sched=<scheduler>

#### 9.1 Instruction Itineraries
<llvm_source>/include/llvm/Target/TargetItinerary.td <br>
<llvm_source>/lib/Target/ARM/ARMScheduleA8.td <br>

Represent instruction latencya and hardware pipeline information.


![image](https://github.com/hitqshao/qishao-notes/assets/23403286/5c502b6c-9972-4fd8-b832-f2cc238e6fe4)

#### 9.2 Hazard Detection

> The ScheduleHazardRecognizer class provides an interface for hazard recognizer implementations and the ScoreboardHazardRecognizer subclass implements the scoreboard hazard recognizer (see the file <llvm_source>/lib/CodeGen/ScoreboardHazardRecognizer.cpp), which is LLVM's default recognizer.

#### 9.3 Scheduling Units

This scheduler runs before and after register allocation, which process both SDNode instruction and MachineInstr.

### 10. Machine Instructions

The InstrEmitter pass, which runs after scheduling, transforms SDNode format into MachineInstr format.<br>
MI format is sequence of instructions rather than DAG.<br>

MI contains significant meta-information about an instruction: <br>
* it stores used and defined registers.
* it distinguishes between register and memory operands (among other types).
* it stores the instruction type (branch, return, call, and terminator, among others)
* it stores predicates such as whether it is commutable or not, and so on.

![image](https://github.com/hitqshao/qishao-notes/assets/23403286/0f94eb3a-7222-405d-b998-ded8773f629f)


llc -print-machineinstrs

llc -print-machineinstrs=<pass-name>


### 11. Register Allocation

### 12. Prologue and epilogue
### 13. Understanding machine code framework




