---
title: MLIR TOY Tutorial
date: 2024-12-10
permalink: /pages/000011/
---

### Chapter 1. Toy Language and AST
Lexer and recursive descent parser construt AST

### Chapter 2. Emit Basic MLIR

Operations: instructions, globals(functions), modules, in LLVM

![image](https://github.com/user-attachments/assets/1547200e-1e13-4075-b202-77be37cf0b74)
From [link](https://medium.com/sniper-ai/mlir-tutorial-create-your-custom-dialect-lowering-to-llvm-ir-dialect-system-1-1f125a6a3008)

Transpose Operation

```
%t_tensor = "toy.transpose"(%tensor) {inplace = true} : (tensor<2x3xf64>) ->
tensor<3x2xf64> loc("example/file/path":12:1)
```

meaning of each part

```
result  = name of operation (input operands) dictionary of traits :
type of operations (input and output), location
```

- A name for the operation.
- A list of SSA operand values.
- A list of attributes.
- A list of types for result values.
- A source location for debugging purposes.
- A list of successors blocks (for branches, mostly).
- A list of regions (for structural operations like functions).

**Opaque API**


**Define a Toy Dialect**

dialect could be defined by c++ or tablegen(declarative specification).

after the definiation, it could be loaded to MLIR Context.
context.loadDialect<ToyDialect>();

**Defining Toy Operations**

```
class ConstantOp : public mlir::Op<
                     /// `mlir::Op` is a CRTP class, meaning that we provide the
                     /// derived class as a template parameter.
                     ConstantOp,
                     /// The ConstantOp takes zero input operands.
                     mlir::OpTrait::ZeroOperands,
                     /// The ConstantOp returns a single result.
                     mlir::OpTrait::OneResult,
                     /// We also provide a utility `getType` accessor that
                     /// returns the TensorType of the single result.
                     mlir::OpTraits::OneTypedResult<TensorType>::Impl> {

 public:
  /// Inherit the constructors from the base Op class.
  using Op::Op;
  ...
  static void build(mlir::OpBuilder &builder, mlir::OperationState &state,
                    mlir::Type result, mlir::DenseElementsAttr value);
```

register operation:

```
void ToyDialect::initialize() {
  addOperations<ConstantOp>();
}
```

**Op vs Operation: Using MLIR Operations**

**Using Operation Definition Specification Framwork**

base Toy_Op

```
class Toy_Op<string mnemonic, list<Trait> traits = []> :
    Op<Toy_Dialect, mnemonic, traits>;
```

ConstantOp

```
def ConstantOp : Toy_Op<"constant"> {
}
```
