---
title: Understanding GPGPU-SIM & GPGPU-SIM UVM_SMART (2)
date: 2024-08-13
permalink: /pages/458726/
---

- libcuda
  * cuda_runtime_api.cc
- src
  * abstract_hardware_model.h/cpp
  * gpgpusim_entrypoint.h/cpp
  * stream_manager.h/cpp
  * cuda-sim
    - cuda-sim.h/cc
    - memory.h/cc
    - opcode.h/def
    - ptx_loader.h/cc
    - ptx.y\
    - ptx_parser.h/cc
    - ptx_ir.h/cc
    - ptx_sim.h/cc
  * gpgpu-sim
    - gpgpu-sim.h/cc
    - shader.h/shader.cc
    - mem_fetch.h/cc
    - stack.h/cc
    - addrdec.h/cc
    - dram.h/cc
    - traffic_breakdown.h/cc

### How do CUDA instructions get executed ?

#### Instruction Level

In opcodes.def, it defines hook for each type of instruction.

In instruction.cc, it implements the detail of each function.
If this is a Load instruction, mem->read() is exectued.

```
// @@@@@@ opcodes.def
OP_DEF(LD_OP,ld_impl,"ld",1,5)
OP_DEF(ST_OP,st_impl,"st",0,5)

// @@@@@@ instructions.cc
void ld_exec( const ptx_instruction *pI, ptx_thread_info *thread ) 
{ 
   const operand_info &dst = pI->dst();
   const operand_info &src1 = pI->src1();
   ...
   mem->read(addr,size/8,&data.s64);
}

void ld_impl( const ptx_instruction *pI, ptx_thread_info *thread ) 
{
   ld_exec(pI,thread);
}
```

#### Abstract Level

The abstract core calls execute_warp_inst_t, which will execute each thread in the warp.

As to each instruction, it will call a "DEFINE" macro, which will invoke function, described in previous Section.

```
// @@@@@@ abstract_hardware_model.cc

void core_t::execute_warp_inst_t(warp_inst_t &inst, unsigned warpId)
{
    for ( unsigned t=0; t < m_warp_size; t++ ) {
        if( inst.active(t) ) {
            if(warpId==(unsigned (-1)))
                warpId = inst.warp_id();
            unsigned tid=m_warp_size*warpId+t;
            m_thread[tid]->ptx_exec_inst(inst,t);
            
            //virtual function
            checkExecutionStatusAndUpdate(inst,t,tid);
        }
    } 
}

// @@@@@@ cuda-sim.cc
void ptx_thread_info::ptx_exec_inst( warp_inst_t &inst, unsigned lane_id)
{
      ...
      switch ( pI->get_opcode() ) {
      #define OP_DEF(OP,FUNC,STR,DST,CLASSIFICATION) case OP: FUNC(pI,this); op_classification = CLASSIFICATION; break;
      ...
      #include "opcodes.def"
      #undef OP_DEF
      default: printf( "Execution error: Invalid opcode (0x%x)\n", pI->get_opcode() ); break;
      }
}

```

#### Detail GPU Mode
In detail GPU, programmed in shader.cc, instruction is executed at issue time.

This is reasonable, as long as the latency and bandwidth is modeled correctly, it is accurate.

```
// @@@@@@ shader.cc
void shader_core_ctx::issue_warp( register_set& pipe_reg_set, const warp_inst_t* next_inst, const active_mask_t &active_mask, unsigned warp_id )
{
    ...
    func_exec_inst( **pipe_reg );
}

void shader_core_ctx::func_exec_inst( warp_inst_t &inst )
{
    execute_warp_inst_t(inst);
    // !!!!!! Notice that as to memory access instruction, it will generate memory access
    if( inst.is_load() || inst.is_store() )
        inst.generate_mem_accesses();
}
```

Then we can go further, how is *issue_warp* called?

In shader.cc, for each cycle, it will check is the status of for each warp.

As to each warp, it will check whether the first instruction in the instruction buffer, after checking scoreboard, if this is no hazard and issue width is not saturated, the warp could be issued.

```
// @@@@@@ shader.cc
void scheduler_unit::cycle()
{
    SCHED_DPRINTF( "scheduler_unit::cycle()\n" );
    bool valid_inst = false;  // there was one warp with a valid instruction to issue (didn't require flush due to control hazard)
    bool ready_inst = false;  // of the valid instructions, there was one not waiting for pending register writes
    bool issued_inst = false; // of these we issued one

    for ( std::vector< shd_warp_t* >::const_iterator iter = m_next_cycle_prioritized_warps.begin();
          iter != m_next_cycle_prioritized_warps.end();
          iter++ ) {
        // Don't consider warps that are not yet valid
        if ( (*iter) == NULL || (*iter)->done_exit() ) {
            continue;
        }
        while( !warp(warp_id).waiting() && !warp(warp_id).ibuffer_empty() ... && (checked <= issued) && (issued < max_issue) ) {
         const warp_inst_t *pI = warp(warp_id).ibuffer_next_inst();
         ...
         if ( (pI->op == LOAD_OP) || (pI->op == STORE_OP) || (pI->op == MEMORY_BARRIER_OP) ) {
             if( m_mem_out->has_free() ) {
                 m_shader->issue_warp(*m_mem_out,pI,active_mask,warp_id);
             }
         } else {
             
         }
    }
}
```

#### Register Hazard
It seems like gpgpu-sim does not use register dependency wakeup, like ROB, which contains a register ID that if dependency instruction has executed, the result transfer through bypassnet work and wakeup pending instructions.

In gpgpu-sim, in the writeback stage, it will release its target registers in scoreboard.

```
// @@@@@@ shader.cc
void shader_core_ctx::writeback()
{
    warp_inst_t** preg = m_pipeline_reg[EX_WB].get_ready();
    warp_inst_t* pipe_reg = (preg==NULL)? NULL:*preg;
    while( preg and !pipe_reg->empty()) {
        m_scoreboard->releaseRegisters( pipe_reg );
        warp_inst_complete(*pipe_reg);
    }
}

// @@@@@@ scoreboard
```

#### Function GPU Mode
[function mode](https://hitqshao.github.io/qishao-notes/pages/458725/) is described in previous blog.

