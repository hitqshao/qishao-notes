---
title: Understanding GPGPU-SIM & GPGPU-SIM UVM_SMART (1)
date: 2024-08-12
permalink: /pages/458725/
---

- libcuda
  * cuda_runtime_api.cc
- src
  * abstract_hardware_model.h/cpp
  * gpgpusim_entrypoint.h/cpp
  * stream_manager.h/cpp
  * cuda-sim
    - cuda-sim.h/cc
      :honeybee:
      ```
      void function_info::ptx_assemble() {
       for ( i=m_instructions.begin(); i != m_instructions.end(); i++ ) {
        // map pc to instruction
        g_pc_to_finfo[PC] = this;
        // This is a uniform array, each entry is one instruction
        m_instr_mem[n] = pI; 
        s_g_pc_to_insn.push_back(pI);
        ssert(pI == s_g_pc_to_insn[PC]);
        pI->set_m_instr_mem_index(n);
        pI->set_PC(PC);
       }
      }
      ```
    - memory.h/cc
    - opcode.h/def
    - ptx_loader.h/cc
    - ptx.y\
      It is a Yacc/Bison grammar file used to parse PTX (Parallel Thread Execution) assembly code, which is a low-level intermediate representation used by NVIDIA GPUs.\
      It defines the grammar rules for PTX assembly code and specifies how different components of PTX code should be interpreted and processed.\
      This includes recognizing various PTX instructions, operands, directives, and control structures, and translating them into an internal representation that the simulator can work with.
   
      When it meets instruction statement it will call add_instruction.
      ```
      statement_list: directive_statement { add_directive(); }
      | instruction_statement { add_instruction();}
      ...
      ```
    - ptx_parser.h/cc
      the add_instruction used in ptx.y will call the following instruction.
      ```
      void add_instruction() 
      {
      ptx_instruction *i = new ptx_instruction(**);
      g_instructions.push_back(i);
      }
      ```
      in the end of function it will add all the instructins into function infomation
      ```
      void end_function()
      {
      ...
      g_func_info->add_inst( g_instructions );
      ...
      }
      ```
    - ptx_ir.h/cc
      ```
      //@@@@@@ ptx_ir.h
      ...
      std::vector<const symbol*> m_args;
      // end_function will put function into this list
      std::list<ptx_instruction*> m_instructions;
      std::vector<basic_block_t*> m_basic_blocks;

      //@@@@@@ ptx_ir.cc
      void gpgpu_ptx_assemble( std::string kname, void *kinfo ) {
       function_info *func_info = (function_info *)kinfo;
       // This will call cuda_sim ptx_assemble function
       func_info->ptx_assemble();
      }
      ```
    - ptx_sim.h/cc
  * gpgpu-sim
    - gpgpu-sim.h/cc
    - shader.h/shader.cc
    - mem_fetch.h/cc
    - stack.h/cc
    - addrdec.h/cc
    - dram.h/cc
    - traffic_breakdown.h/cc




### How did GPGPU-sim get instruction from CUDA?

:honeybee: show how Yacc/Bison grammar file is used to add instruction in function_info.
Now we will describe how GPGPU-sim execute each instructin.

####

abstract_hardware_model.cc implement this function, if you provde a warpId, it can return warp_instruction.\
Thus, if we know next pc, we can use ptx_fetch_inst to get instruction.
```
// @@@@@@ abstract_hardware_model.cc
//! Get the warp to be executed using the data taken form the SIMT stack
warp_inst_t core_t::getExecuteWarp(unsigned warpId)
{
    unsigned pc,rpc;
    m_simt_stack[warpId]->get_pdom_stack_top_info(&pc,&rpc);
    warp_inst_t wi= *ptx_fetch_inst(pc);
    wi.set_active(m_simt_stack[warpId]->get_active_mask());
    return wi;
}
```


```
// @@@@@@ cuda-sim.cc
const warp_inst_t *ptx_fetch_inst( address_type pc )
{
    return function_info::pc_to_instruction(pc);
}

// @@@@@@ ptx_ir.h
static const ptx_instruction* pc_to_instruction(unsigned pc) 
{
  if( pc < s_g_pc_to_insn.size() )
      return s_g_pc_to_insn[pc];
  else
      return NULL;
}
```


